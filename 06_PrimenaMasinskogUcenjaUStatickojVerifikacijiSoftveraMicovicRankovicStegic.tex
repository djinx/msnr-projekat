% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{xcolor}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{booktabs,hhline}

\usepackage{multirow}       % used for making multirow tables (Nemanja)

%\usepackage[english,serbian]{babel}
\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\newtheorem{primer}{Пример}[section] %ćirilični primer
%\newtheorem{primer}{Primer}[section]

\newtheorem{definic}{Дефиниција}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\begin{document}

%TODO smisliti naslov
\title{Примена машинског учења у статичкој верификацији софтвера\\ \small{Семинарски рад у оквиру курса\\Методологија стручног и научног рада\\ Математички факултет}}

\author{Лазар Ранковић, Немања Мићовић, Урош Стегић\\ lazar.rankovic@outlook.com, nmicovic@outlook.com, mi10287@alas.matf.bg.ac.rs}
\date{}
\maketitle

\abstract{
Испитивање исправности програма представља значајну област рачунарства. Експанзија научних као и софтверских решења може имати како позитнивних тако и негативних последица. С тога је потребно поседовати механизам којим се може испитати исправност програмског кода. Међутим, због неодлучивости Халтинг проблема и других ограничења, јављају се различити проблеми приликом испитивања исправности софтвера. Технике машинског учења проналазе све већу примену у различитим областима рачунарства, и примећено је да се неки од проблема статичке верификације могу ефикасно решити применом ових техника. Овај рад ће дати преглед одређених проблема статичке верификације, као и механизме машинског учења који су постигли значајна побољшања.

\tableofcontents

\newpage

% ---------------------------------------------------------------------------------------------------------------------
\section{Увод}
% ---------------------------------------------------------------------------------------------------------------------
Рачунарски системи имају све значајнију примену у областима индустрије где грешке проузроковане софтвером могу имати озбиљне последице. Програми се користе за аутоматско навођење возила, у нуклеарним електранама, медицини и другим областима. Ове грешке могу довести до пада авиона (ако се ради о аутоматском навођењу возила), експлозију нуклеарних реактора итд. Због тога је потребно имати механизме који формално доказују исправност софтвера и тиме одстрањују могућност грешака. Област верификације софрвера се бави анализом програмских решења и испитивањем исправности програмског кода. Последњих година су достигнути велики напреци у развоју алата за верификацију, али постоје многи проблеми и ограничења у процесу анализе софтвера која се тешко превазилазе. Анализа програмског кода се заснива на математичким моделима и формалним техникама се испитују својства ових модела. Међутим, у неким ситуацијама је коришћење стриктних математичких механизама тешко или чак немогуће за аутоматизацију, што овај процес чини још компликованијим. Са друге стране област машинског учења проналази примену и постиже добре резултате у различитим аспектима рачунарства, у које спада и верификација софтвера \cite{new-cv, old-cv}.  У овом раду ће бити описане неке технике верификације софтвера као и преглед механизама машинског учења који могу побољшати сам процес испитивања исправности софтвера.
% ---------------------------------------------------------------------------------------------------------------------
\section{Верификација софтвера}
% ---------------------------------------------------------------------------------------------------------------------

\emph{Верификација софтвера} је дисциплина развоја софтвера која за циљ има проверу да ли програм задовољава све унапред задате захтеве. Ти захтеви су представљени спецификацијом свих жељених особина програма и дефинишу се пре процеса верификације. Највећа примена верификације софтвера је у оптимизацији кода и провери исправности.


Потребно је направити разлику између тоталне и делимичне исправности. Испитивање тоталне исправности захтева да се за све могуће улазе покаже заустављање програма. Доказ заустављања у општем случају није могуће извести \cite{turing}. Такође, испитивање нетривијалних семантичких својстава је неодлучив проблем \cite{rice}.
Према томе, у рачунарству је довољно испитати делимичну исправност софтвера, тј. довољно је показати да ће резултат извршавања програма бити валидна вредност.


Два приступа при верификацији софтверa су \emph{динамичка верификација} и \emph{статичка верификација} \cite{milena}.
\begin{itemize}
\item \textbf{Динамичка верификација}\\
Овај вид верификације се врши у току извршавања програма и то најчешће скупом 
унапред припремљених тестова који морају бити испуњени. Очигледно је да због неисцрпне варијације могућих улаза, овај вид тестирања нема за циљ валидацију програма, већ је циљ динамичке верификације проналажење грешка на неком нетривијалном скупу тестова.
\item \textbf{Статичка верификација}\\
Статичка верификација софтвера подразумева анализу софтвера без његовог извршавања, тачније анализу кода применом неке од технника које ће бити описане у наставку. Анализу кода може обављати човек, а може се и аутоматизовати. Аутоматизација подразумева описивање (па чак и превођење) кода језиком изабране математичке теорије.
\end{itemize}


% ---------------------------------------------------------------------------------------------------------------------
\section{Технике статичке верификације}
% ---------------------------------------------------------------------------------------------------------------------
Претходним поглављем су дефинисани основни појмови верификације софтвера. Предочено је да је немогуће у општем случају испитати заустављање програма и анализирати нетривијална семантичка својства. Ово поглавље ће дати увид у аутоматизоване технике статичке анализе.

\paragraph{Апстрактна интерпретација (енг.  Abstract Interpretation)} је теорија семантичке апроксимације чија је идеја да изгради нову семантику над програмским језиком тако да се конкретан програм увек завршава\cite{survey}. Тако се анализа програма врши над апстрактном семантиком да би се добила апроксимација над целом семантиком. Коришћење апстрактне интерпретације се омогућава помоћу две функције: функције која пресликава конкретне вредности у апстрактне вредности и функције која слика апстрактне вредности у конкретне вредности.  Користећи овај математички оквир је релативно лако показати да ако се програм завршава у новој семантици програм ће бити коректан и у стварној семантици.


\paragraph{Симболичкa анализа (енг. Symbolic Analysis)} је метод статичке анализе који анализира програмске вредности који могу да се мењају. Овај метод има за циљ да изведе математички модел који прецизно описује израчунавање, заправо може се посматрати као нека врста компајлера који преводи програм у симболичке изразе. Квалитет алгебарских система као што су: Axiom, Derive, Macsyma, Maple, Mathematica, MuPAD и Reduce је веома битан јер квалитет овог начина анализе у великој мери зависи од паметних алгебарских упрошћавања\cite{survey}. 


\paragraph{Проверавање ограничених модела (енг. Bounded model checking)} је техника верификације која се највише користи у верификација логичких кола. Потребно је програм описати исказним формулама након чега се проверава њихова задовољивост. Резултат САТ (енг. SATISFIABILITY) решавача је формула која може бити задовољива што би значило да програм није коректан и да је генерисана комбинација заправо контрапример који може представљати добру основу за дебаговање у супротном формула је незадовољива што значи да је програм исправан.\cite{dkw2008, survey}.

% ---------------------------------------------------------------------------------------------------------------------
\section{Машинско учење}
% ---------------------------------------------------------------------------------------------------------------------
\label{sec:ml_intro}
У претходним поглављима је описана статичка верификација софтвера. Показана је важност те области и изложене су технике верификације. Ово поглавље ће приближити област машинског учења и описаће главне аспекте ове дисциплине.

\subsection{Основе машинског учења}
\begin{definic}
%A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E.
``За програм кажемо да учи из искуства E кроз обављање задатка T са мером квалитета P, ako повећањем искуства E расте мера P за обављен задатак T.''
\\[5pt]
\rightline{{\rm --- Tom M. Mitchell} \cite{tom-ml}}
\end{definic}


Машинско учење се може посматрати као област рачунарства која се бави анализом алгоритама који генерализују. Са практичног аспекта, генерализација може значити уопштавање закона над датим подацима.


Три најзначајније подобласти машинског учења су: \textit{надгледано учење}, \textit{ненадгледано учење} и \textit{учење условљавањем}. Подаци из којих алгоритми машинског учења уче, могу бити обележени, необележени и могу се генерисати у фази учења. Оваква природа података је основ за разликовање три наведене подобласти \cite{tom-ml}.


Међу многим проблемима над којима су често примењивани алгоритми машинског учења, истактнути су проблем регресије и проблем класификације. Под проблемом класификације се подразумева испитивање датог објекта и одређивање класе којој он припада на основу његових својстава (атрибута). Типичан пример класификације је одређивање порекла тумора на основу његове величине. Проблем регресије представља предвиђање понашања непрекидне променљиве. Пример регресије је предикција цене стамбеног објекта на основу његове величине, броја соба и разних других релевантних карактеристика.


Пре примене машинског учења потребно је проучити проблем који се решава, уочити његове специфичности и припремити и анализирати податке из којих ће алгоритми учити. Након детаљне анализе, врши се одабир одговарајућег математичког модела. Изабрани модел се даље тренира над подацима. Тренинг се понавља довољан број пута при чему у свакој итерацији модел евалуира тј. мери се грешка коју тај модел прави. Након сваког мерења, у зависности од алгоритма, врши се корекција модела у циљу минимизације грешке.
 


\subsection{Технике машинског учења}
О општој слици примене алгоритама машинског учења је било више речи у претходном поглављу. Како је проблем класификације централни проблем над којим се примењује машинско учење у статичкој верификацији, биће представљена два алгоритма која решавају тај проблем. Зарад потпуности, биће описан и један алгоритам решавања регресионих проблема.


\subsubsection*{Линеарна регресија}
Као што је речено у уводном делу поглавља \ref{sec:ml_intro}, регресиони проблем представља предвиђање циљне променљиве непознате инстанце на основу осталих њених атрибута. Нека је $y_i$ циљна променљива, а $\vec{x} = (x_1, x_2, ..., x_n)$ вектор атрибута. У примеру предикције вредности куће то могу бити број соба, квадратура куће итд. Инстанца из скупа података ће онда бити $(\vec{x}_i, y_i)$. Модел линеарне регресије, параметризован вектором $w$, који описује законитост је следећи:
\begin{equation}
    h(\vec{x}_i) = w^T \cdot \vec{x}_i
\end{equation}


Грешка коју модел прави је потребно представити погодним избором функције грешке $L(w)$. Чест избор ове функције је средњеквадратна грешка коју модел прави над свим инстанцама из тренинг скупа.
\begin{equation}
L(w) = \frac{1}{N}\sum \limits_{i=1}^{N} (h(\vec{x}_i) - y_i)^2
\end{equation}

Тренинг се врши тако што се одређеном оптимизационом техником минимизује функција грешке по параметрима $w$.


\subsubsection*{Стабла одлучивања}
Стабла одлучивања представљају један од основних метода класификације. Употребу стабала одлучивања оправдава њихова висока интерпретабилност \cite{dct-survey}. У листовима стабла одлучивања се налазе вредности циљне променљиве, односно у случају класификације, класе којима инстанца може припасти. Унутрашњи чворови стабла представљају атрибуте по којима се врши подела. Када су ти атрибути категоричког типа, потомци датог чвора су добијени из свих могућих вредности које тај категорички атрибут може имати. У случају да је атрибут некатегоричког типа, најчешће се врши подела могућих вредности на дисјунктне интервале тако да свако дете тог чвора одговара једном од интервала. Слика \ref{fig:stablo} приказује једно могуће стабло одлучивања добијено на основу података.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{./slike/decision_tree.png}
\end{center}
\caption{Стабло одлучивања}
\label{fig:stablo}
\end{figure}


\subsubsection*{Метода потпорних вектора}
Проблем класификације се може разматрати у следећем контексту. Инстанце које се класификују су представљене тачкама у неком високодимензионалном простору. Бинарни класификатор је хиперраван која дели простор на два дела, тако да се у једном делу простора нађу све инстанце које припадају једној класи, а у другом делу ће се наћи оне које припадају другој класи. Раздвајајућих хиперравни може бити више, па је зато потребно одабрати хиперраван која боље описује поделу међу подацима \cite{svm-intro}.


Маргина класификације је најмање растојање између тачака које се налазе у различитим потпросторима и бинарног класификатора. Слика \ref{fig:svm} приказује хиперравни $B_1$ и $B_2$. Прва хиперраван боље раздваја податке. Маргина $(b_{11}, b_{12})$ je значајно већа од маргине $(b_{21}, b_{22})$ и то је оно што први класификатор чини знатно бољим.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{./slike/svm.png}
\end{center}
\caption{Приказ различитих хиперравни}
\label{fig:svm}
\end{figure}

Максимизацијом маргине се добија класификатор који боље описује поделу. Зарад конвенције, проблем максимизације се своди на проблем минимизације, те се добија следећи оптимизациони проблем:
\begin{equation}
    \min_{w, w_0} \frac{ {\norm{w}}^2 }{2}
\end{equation}


Линеарна регресија, стабла одлучивања и метод потпорних вектора су приказани у овом поглављу због својих примена у проблемима статичке верификације. Поглавље \ref{sec:primene} се бави овим применама. Следеће поглавље ће представити релевантне проблеме верификације и даће основ за примену ових метода.

% ---------------------------------------------------------------------------------------------------------------------
\section{Одабрани проблеми статичке верификације}
% ---------------------------------------------------------------------------------------------------------------------
%\textit{Уређени бинарни дијаграми одлучивања} (енг. ordered binary decision diagrams, OBDD) \cite{obdd} представљају алат за ефикасну анализу Булових функција.\cite{eval-obdd}\cite{logic-ver-synth}. Логичке импликације бивају откривене конструисањем УБДО за разне улазе. Симболичком обрадом УБДО дијаграма и применом закона контрапозиције се могу научити додатне импликације. \cite{Jain}. Статичка верификација се даље спроводи успостављањем еквиваленције између два УБДО, тј. проналаском одговарајућег скупа импликација. Еквивалентност два УБДО се изводи проналажењем сличности унутрашње структуре између два дијаграма.
До сада смо видели стандардне проблеме и технике статичке верификације и машинског учења. У овом поглављу ћемо издвојити проблеме верификације на које су, применама алгоритама машинског учења постигнути значајнији резултати.


Статичка верификација мора бити у стању да разликује позитивна стања програма од негативних.
Негативна су она која доводе програм до грешке. \textit{Интерполантама} (енг. interpolants)
називамо предикате који раздвајају позитивна од негативних стања.
У статичкој верификацији се коришћењем оваквих интерполанти гради даљи доказ.
Показано је да се ове интерполанте могу интерпретирати као бинарни класификатори.
Проблем који се овде јавља је генерисање интерполанти, тј. проналажење одговарајућег класификатора \cite{Sharma_interpolantsas}.
У делу  \ref{ssec:interpolant} су детаљније описани приступи коришћени у \cite{Sharma_interpolantsas} и \cite{KrishnaPW15}.

Поред интерполанти, могуће је препознати нетривијална својства програма која даље резултују грешком.
Грађењем \textit{класификатора нетачне инваријанте} (енг. False Invariant Classifier) је могуће рангирати
својства програма по томе колику вероватноћу за грешком та својства проузрокују.
Одређивање нетривијалног својства датог програма је у општем случају неодлучив проблем \cite{Brun04findinglatent, turing}.
Део \ref{ssec:latent_dt} приказује примену стабала одлучивања као помоћ при рангирању својстава програма који могу
довести до грешке.

Код апстрактне интерпретације је остварив баланс између прецизности изгенерисане инваријанте и скалабилности система за верификацију. Овај баланс је последица детаљне анализе апстрактног синтаксног стабла. Одабир инваријанте је тежак проблем и показано је да се може утврдити тестирањем \cite{KrishnaPW15, Sharma_interpolantsas}.


% ---------------------------------------------------------------------------------------------------------------------
%\section{Неке примене техника машинског учења у статичкој верификацији}
\label{sec:primene}
% ---------------------------------------------------------------------------------------------------------------------

\subsection{Проналажење интерполанти}
%\paragraph{Проналажење интерполанти}
\label{ssec:interpolant}

Примена машинског учења у проналажењу интерполанти огледа се у добијању модела
који представља саму интерполанту. У делу \ref{sssec:interpolant_svm} изложене су основе из \cite{Sharma_interpolantsas} базиране на методу
потпорних вектора, док је у делу \ref{sssec:interpolant_dt} изложен приступ из рада \cite{KrishnaPW15} базиран на стаблима одлучивања. Експериментални резултати
показали су да су приступи базирани на машинском учењу упоредиви са традиционалним техникама статичке верификације софтвера.

%Користи се теорија линеарне аритметика о којој се више може пронаћи у \cite{Kroening2008}.

\subsubsection{Проналажење интерполанти користећи метод потпорних вектора}
\label{sssec:interpolant_svm}

Нека су $A$ и $B$ формуле у теорији линеарне аритметике \cite{Kroening2008}.
\begin{equation}
\phi ::= w^Tx + d \geq 0 \ | \ true \ | \ false \ | \ \phi \land \phi \ | \ \phi \lor \phi \ | \ \neg \phi
\end{equation}
При чему је $\vec{w} = (w_1, ..., w_n)^T \in R^n$ вектор константи у простору $R^n$; $\vec{x} = (x_1, ..., x_n)^T$
вектор променљивих из простора $R^n$.

\begin{definic}
Интерполанта за пар формула (А, B) тако да $A \land B \equiv \bot$ је формула I која задовољава $A \Rightarrow I, I \land B \equiv \bot$
при чему формула I садржи само променљиве које се јављају у формулама A и B.
\end{definic}

На коду који следи приказан је програмски код коришћен у \cite{Sharma_interpolantsas} као илустрација.
Функција непознат број пута инкрементира променљиве $x$ и $y$, потом их декрементира све док променљива $x$
не постане 0. Коначно, уколико је $y \neq 0$ онда програм одлази у стање грешке.
Приметимо да је инваријанта $x = y$ довољна да се докаже да програм никад неће доћи у стање грешке.

%\noindent\rule{12cm}{0.4pt}
\begin{verbatim}
funkcija primer()
{
1:     x = y = 0;
2:     while (e)
3:     { x++; y++; }
4:     while (x != 0)
5:     { x--; y--; }
6:     if (y != 0)
7:         greska();
}
\end{verbatim}
%\noindent\rule{12cm}{0.4pt}

%\begin{figure}[h!]
%\begin{center}
%    \includegraphics[scale=0.14]{./slike/interpolant_code.png}
%\end{center}
%\caption{Пример кода}
%\label{fig:interpolant_example}
%\end{figure}

Претпоставимо да се функцијa \texttt{primer()} извршила на следећи начин по линијама кода: $(1, 2, 3, 2, 4, 5, 4, 6, 7)$. Приметимо
да наведен ток програма води у стање грешке. Поделимо ток на два скупа, $A$ и $B$ и пронађимо интерполанте.

Скуп A садржи вредности $x$ и $y$ које се добијају након извршавања линија 1, 2 и 3. У скупу B се налазе оне вредности $x$ и $y$
које би се добиле уколико би програм извршио линије 4, 5, 6 и 7 чиме би програм дошао у завршно стање.

Имамо да $A \land B \equiv \bot$ при чему важи:

\begin{equation*}
\begin{split}
    A & \equiv x_1 = 0 \land y_1 = 0 \land ite(e,\ x = x_1 + 1 \land y = y_1 + 1, \ x = x_1 \land y = y_1)     \\
    B & \equiv ite(x = 0,\ x_2 = x \land y_2 = y,\ x_2 = x - 1 \land y_2 = y-1) \land x_2 = 0 \land \neg (y_2 = 0)
\end{split}
\end{equation*}

При чему $ite$ означава наредбу \texttt{if-then-else}.

$A$ представља скуп достижних стања док $B$ представља скуп стања која воде у стање грешке. Интерполанта је доказ да су
скупови $A$ и $B$ дисјунктни и изражава се користећи заједничке променљиве из скупова $A$ и $B$. Затим, помоћу доказивача теорема се рачунају вредности за $(x, y)$ које задовољавају формуле $A$ и $B$ \cite{Sharma_interpolantsas}.

Добијене вредности представљају скуп инстанци над којим се може тренирати класификациони модел (попут логистичке регресије или потпорних вектора).
Позитивне инстанце представљају вредности променљивих које задовољавају формулу $A$ и аналогно, негативне инстанце представљају вредности
променљивих које задовољавају формулу $B$.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.15]{./slike/interpolant.png}
\end{center}
\caption{Класификација у тражењу интерполанти}
\label{fig:interpolant_svm}
\end{figure}

Слика \ref{fig:interpolant_svm} приказује вредности променљивих $(x, y)$ за $A$ као плусеве (тачке $(0, 0)$ и $(1, 1)$)
и $B$ као кружиће (тачке $(1, 0)$ и $(0, 1)$). Приказани модел је добијен коришћењем метода потпорних вектора. Резултујуће праве одговарају једначинама:
\begin{equation*}
\begin{split}
    e_1: 2y &= 2x + 1 \\
    e_2: 2y &= 2x - 1
\end{split}
\end{equation*}
Интерполанта која се одавде може извести је
\begin{equation*}
2y \leq 2x + 1 \, \land 2y \geq 2x - 1
\end{equation*}

Овај предикат представља инваријанту чијим доказивањем се показује да програм не може доћи у стање грешке.
Једноставнија интерполанта $x = y$ се може добити транислирањем добијених правих што ближе позитивним истанцама,
докле год се одржава сепарабилност позитивних и негативних инстанци.

Табела \ref{table:interpolant_table} приказује резултате из \cite{Sharma_interpolantsas} на неким од познатих
примера. Интерполанте које су означене са \textit{исто} су интерполанте које су добијене користећи решавач \textsc{OpenSMT} \cite{opensmt} у истом раду.  

\begin{table}[]
\centering
\caption{Добијене интерполанте на неким од познатијих тест примера у области.}

\label{table:interpolant_table}

\scalebox{0.9}{
\begin{tabular}{|c|c|l|}
\hline
\textbf{Датотека} & \textbf{Време (с)} 	& \textbf{Интерполанта}                                                     			\\ \hline
\texttt{f1a} 	& 0.022              	& \texttt{((y = 1 | x \textless= 0) \& x = 1) | (y = 0 \& (y = 1 | x \textless= 0))} 	\\ \hline
\texttt{ex1}    & 0.021              	& \texttt{xa + 2*ya >= 0 | xa + 2*ya >= 5 | xa + 2*ya >= 5}                             \\ \hline
\texttt{f2}     & 0.20               	& \texttt{y <= 3*x | y <= 3*x + 1 | y <= 3*x + 1} 										\\ \hline
\texttt{nec1}   & није доступно      	& Није пронађена oд стране алгоритма                                           			\\ \hline
\texttt{nec2}   & 0.018 				& \texttt{x < y} (исто) 																\\ \hline
\texttt{nec3}   & 0.016      			& \texttt{y <= 9} (исто)																\\ \hline
\texttt{nec4}   & 0.021      			& \texttt{(x = y | y = 0) | (y = x) | (y = x)} 											\\ \hline
\texttt{nec5}   & 0.018      			& \texttt{s >= 0} (исто) 																\\ \hline
\texttt{pldi08} & 0.017      			& \texttt{y > x}																		\\ \hline
\texttt{fse06}  & 0.017      			& \texttt{y + x >= 0 \& y >= 0 \& y >= 0 \& y >= 0}										\\ \hline
\end{tabular}}
\end{table}

\subsubsection{Проналажење интерполанти користећи стабла одлучивања}
\label{sssec:interpolant_dt}

Интерполанте се могу извести и другим методима машинског учења. Рад \cite{KrishnaPW15} илуструје приступ који
користи стабла одлучивања. За програмски код се генеришу позитивне и негативне инстанце над којима се гради
стабло одлучивања користећи похлепни алгоритам. Правила добијена у стаблу се трансформишу у формулу која
се потом проверава да ли је инваријанта користећи \textsc{SMT} решавач.

Резултати су показали да једноставни похлепни алгоритам који гради стабло даје и једноставне формуле
за интерполанте. Стабло је лако научило комплексне бинарне инваријанте као једноставне конјункције.

Слика \ref{fig:interpolant_example2} приказује пример програма и његова стања која се могу добити на основу
покретања самог програма. Добра стања можемо добити пратећи претпоставке (линија 2), бележећи ток променљивих
и провером да ли је испуњен услов $x \neq 0$ са линије 12. Лоша стања можемо добити игноришући услов са линије 2.
На пример, тачка $(-2, -2)$ тачка $(-4, -4)$ представљају лоша стања.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.18]{./slike/interpolant2.png}
\end{center}
    \caption{Пример програма. Лева страна приказује код, десна страна садржи добра стања (плаве тачке) и лоша
    стања (црвене тачке).}
\label{fig:interpolant_example2}
\end{figure}

Слика \ref{fig:interpolant_dt} приказује стабло добијено применом алгоритма описаног у \cite{KrishnaPW15}.
Добијени алгоритам је сложености $O(mn \log(n))$, где је $m$ број атрибута а $n$ број инстанци.
Детаљни резултати изложени су у раду, а сам метод се показао задовољавајуће и упоредиво у односу
на традиционалне методе статичке верификације.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.14]{./slike/stablo_odlucivanja.png}
\end{center}
    \caption{Стабло одлучивања добијено за пример са слике \ref{fig:interpolant_example2}.}
\label{fig:interpolant_dt}
\end{figure}

\subsection{Грађење класификатора нетачне инваријанте}
\label{ssec:latent_dt}

Грађење класификатора нетачне инваријанте \cite{Brun04findinglatent} представља приступ којим се користећи класификатор рангирају
својства програма по њиховој вероватноћи да проузрокују грешку. Програмеру се приказује листа пронађених
програмских својстава која треба да скрати простор претрагe у потрази за грешком. У раду су коришћене две техникe класификације
машинског учења, метода потпорних вектора и метода стабла одлучивања. Као помоћ при проналажењу својстава програма, користи
се \textsc{Daikon} динамички детектор инваријанти \cite{Daikon}.

\textsc{Daikon} детектује својства специфичних делова програма попут улаза и излаза из процедура.
За скаларне променљиве $x$, $y$ и $z$, и константе $a$, $b$ и $c$, неки примери својстава су:
\begin{itemize}
    \item једнакост са константом ($x = a$);
    \item провера опсега ($a \leq x \leq b$);
    \item линеарне везе ($z = ax + by + c$);
    \item уређење ($x \leq y$);
    \item функције ($y = fn(x)$).
\end{itemize}

За секвенцијалне променљиве (низови, листе) нека својства су:
\begin{itemize}
    \item минимум и максимум;
    \item лексикографско уређење;
    \item својства која важе за све елементе;
    \item припадност ($x \in y$).
\end{itemize}

\textsc{Daikon} може пронаћи и импликације попут \textit{Ако је $p \neq null$ онда $p.vrednost > x$}
и дисјункције попут \textit{p.vrednost > c $\lor \ p.levo \in T$}.

Добијена својства је потребно превести у векторе како би се омогућила примена алгоритама машинског учења.
Један пример кодирања добијених својстава је приказан на табели \ref{table:latent_coding}.
У раду је кодирање изведено у векторе димензије 388 јер се показало да су коришћени алгоритми
успевали да игноришу ирелевантне атрибуте те висока димензионалност није сметала.


% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[]
\centering
\caption{Пример кодирања програмских својстава у вектор. Број променљивих је означен са \#v}
\label{table:latent_coding}
\begin{tabular}{l|c|c|c|c|c|c|c|c|c|}
\hline
\multicolumn{1}{|l|}{\multirow{2}{*}{Својства}} & \multicolumn{4}{c|}{Једначина} & \multicolumn{3}{c|}{Тип променљиве} & \multirow{2}{*}{\#v} & \multirow{2}{*}{Резултат} \\ \cline{2-8}
\multicolumn{1}{|l|}{}                          & $\leq$  & $=$  & $\neq$ & $\subseteq$ & int       & double       & niz      &                      &                           \\ \hline
\multicolumn{1}{|l|}{out[1] $\leq$ in[1]}                          & 1           & 0  & 0  & 0      & 0         & 1            & 0        & 2                    & 19                        \\ \hline
\multicolumn{1}{|l|}{$\forall$\ i: in[i] $\leq$ 100}                          & 1           & 0  & 0  & 0      & 0         & 1            & 0        & 1                    & 16                        \\ \hline
\multicolumn{1}{|l|}{in[0] $=$ out[0]}                          & 0           & 1  & 0  & 0      & 0         & 1            & 0        & 2                    & 15                        \\ \hline
\multicolumn{1}{|l|}{out.dužina $=$ in.dužina}                          & 0           & 1  & 0  & 0      & 1         & 0            & 0        & 2                    & 13                        \\ \hline
\multicolumn{1}{|l|}{in $\subseteq$ out}                          & 0           & 0  & 0  & 1      & 0         & 0            & 1        & 2                    & 12                        \\ \hline
\multicolumn{1}{|l|}{out $\subseteq$ in}                          & 0           & 0  & 0  & 1      & 0         & 0            & 1        & 2                    & 12                        \\ \hline
\multicolumn{1}{|l|}{in $\neq$ null}                          & 0           & 0  & 1  & 0      & 0         & 0            & 1        & 1                    & 10                        \\ \hline
\multicolumn{1}{|l|}{out $\neq$ null}                          & 0           & 0  & 1  & 0      & 0         & 0            & 1        & 1                    & 10                        \\ \hhline{|=|=|=|=|=|=|=|=|=|=|}
\multicolumn{1}{|l|}{Тежине модела}             & 7           & 3  & 2  & 1      & 4         & 6            & 5        & 3                    & \multicolumn{1}{l|}{}     \\ \cline{1-10} 
\end{tabular}
\end{table}

%\begin{figure}[h!]
%\begin{center}
%\includegraphics[scale=0.18]{./slike/latent_errors_table.png}
%\end{center}
    %\caption{Пример кодирања програмских својстава у вектор. Број променљивих је означен са \#v}
%\label{fig:latent_coding}
%\end{figure}

У даљем тексту је приказан програмски код који се користи за илустрацију у \cite{Brun04findinglatent}, а у табели \ref{table:latent_example}
листа програмских својстава који могу бити потенцијални проблеми. Добијена листа програмских својстава
представља класификоване инстанце које потенцијално откривају грешку.

\begin{verbatim}
// Vraca sortiranu kopiju argumenta
double[] bubble_sort(double[] in) {
    double[] out = kopiraj_niz(in);
    for (int x = out.duzina - 1; x >= 1; x--)
    // donja granica treba da bude 0, ne 1
    for (int y = 1; y < x; y++)
        if (out[y] > out[y+1])
            razmeni(out[y], out[y+1])
    return out;
}
\end{verbatim}


%\begin{figure}[h!]
%\begin{center}
%\includegraphics[scale=0.16]{./slike/latent_code.png}
%\end{center}
%    \caption{Пример програмског кода.}
%\label{fig:latent_code}
%\end{figure}

%\begin{figure}[h!]
%\begin{center}
%\includegraphics[scale=0.16]{./slike/latent_examples.png}
%\end{center}
	%\caption{Листа понуђених програмских својстава}
%\label{fig:latent_example}
%\end{figure}

\begin{table}[]
\centering
\caption{Листа понуђених програмских својстава}
\label{table:latent_example}
\begin{tabular}{|l|c|}
\hline
\multicolumn{1}{|c|}{Својства} & Открива грешку? \\ \hline
out[1] $\leq$ in[1]                           & Да              \\ \hline
$\forall i:$ in[i] $\leq$ 100                           & Не              \\ \hline
in[0] = out[0]        & Да              \\ \hline
out.duzina = in.duzina         & Не              \\ \hline
in $\subseteq$ out                  & Не              \\ \hline
out $\subseteq$ in                  & Не              \\ \hline
in $\neq$ null                     & Не              \\ \hline
out $\neq$ null                    & Не              \\ \hline
\end{tabular}
\end{table}

% ---------------------------------------------------------------------------------------------------------------------
\section{Закључак}
% ---------------------------------------------------------------------------------------------------------------------
Радови приказани у делу \ref{sec:primene} показали су да област машинског учења може пронаћи примену у области статичке
верификације софтвера. Добијени резултати су били барем упоредиви са другим приступима, а у неким случајевима и доста
бољи. Неки од проблема који се јављају при употреби алгоритама машинског учења јесу неинтерпретабилност добијеног модела и
неегзактна предвиђања које модел врши. Проблем интерпретабилности је превазиђен стаблима одлучивања \cite{KrishnaPW15, Sharma_interpolantsas}
која су позната да дају интерпретабилне моделе, док је проблем неегзактног предвиђања ублажен у раду \cite{Brun04findinglatent}
где се као резултат даје листа програмских својстава које човек анализира. Уколико је неко својство погрешно класификовано,
неће проузроковати велику грешку.

\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski}
\bibliographystyle{plain}


\end{document}
