% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{xcolor}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{multirow}       % used for making multirow tables (Nemanja)

%\usepackage[english,serbian]{babel}
\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\newtheorem{primer}{Пример}[section] %ćirilični primer
%\newtheorem{primer}{Primer}[section]

\newtheorem{definic}{Дефиниција}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\begin{document}

%TODO smisliti naslov
\title{Примена машинског учења у статичкој верификацији софтвера\\ \small{Семинарски рад у оквиру курса\\Методологија стручног и научног рада\\ Математички факултет}}

\author{Лазар Ранковић, Немања Мићовић, Урош Стегић\\ lazar.rankovic@outlook.com, nmicovic@outlook.com, mi10287@alas.matf.bg.ac.rs}
\date{}
\maketitle

\abstract{
%U ovom tekstu je ukratko prikazana osnovna forma seminarskog rada. Obratite pažnju da je pored ove .pdf datoteke, u prilogu i odgovarajuća .tex datoteka, kao i .bib datoteka korišćena za generisanje literature. Na prvoj strani seminarskog rada su naslov, apstrakt i sadržaj, i to sve mora da stane na prvu stranu! Kako bi Vaš seminarski zadovoljio standarde i očekivanja, koristite uputstva i materijale sa predavanja na temu pisanja seminarskih radova. Ovo je samo šablon koji se odnosi na fizički izgled seminarskog rada (šablon koji \emph{morate} da ispoštujete!) kao i par tehničkih pomoćnih uputstava. Molim Vas da kada budete predavali seminarski rad, imenujete datoteke tako da sadrže temu seminarskog rada, kao i imena i prezimena članova grupe (ili samo temu i prezimena, ukoliko je sa imenima predugačko). Predaja seminarskih radova biće isključivo preko web forme, a NE slanjem mejla.

Испитивање исправности програма представља значајну област рачунарства. Експанзија научних као и софтверских решења може имати како позитнивних тако и негативних последица. С тога је потребно поседовати механизам којим се може испитати исправност програмског кода. Међутим, због неодлучивости Халтинг проблема и других ограничења, јављају се различити проблеми приликом испитивања исправности софтвера. Технике машинског учења проналазе све већу примену у различитим областима рачунарства, и примећено је да се неки од проблема статичке верификације могу ефикасно решити применом ових техника. Овај рад ће дати преглед одређених проблема статичке верификације, као и механизме машинског учења који су постигли значајна побољшања.
%Верификација софтвера постаје све битнија дисциплина (реф). Класични приступи су добри, имају супер резултате (реф). Машинско учење постаје све популарније. Показаћемо преглед радова који примењују алгоритме машинског учења у циљу убрзања процеса верификације (реф).
%Пошто ћемо абстракт писати на крају, онда док радимо да искористимо
%ово за интерне потребе. До сада прегледани радови:\\
%\begin{itemize}
%   \item{Finding latent code errors via machine learning over program executions
%       \cite{Brun04findinglatent}}
%   \item{Learning Invariants using Decision Trees
%       \cite{KrishnaPW15}}
%   \item{ICE: A Robust Framework for Learning Invariants
%       \cite{Garg2014}}
%   \item{Interpolants as Classifiers
%       \cite{Sharma_interpolantsas}}
%   \item{Advanced Verification Techniques Based on learning
%       \cite{Jain}}
%   \item{A Survey of Static Program Analysis Techniques
%       \cite{survey}}
%   \item{A Survey of Automated Techniques for Formal Software Verification
%       \cite{dkw2008}}
%   \item{Regresiona verifikacija softvera korišćenjem sistema LAV
%       \cite{milena}}
%\end{itemize}

\tableofcontents

\newpage

% ---------------------------------------------------------------------------------------------------------------------
\section{Uvod}
% ---------------------------------------------------------------------------------------------------------------------
Рачунарски системи имају све значајнију примену у нуклеар. Софтвер који контролише то мора да буде исправан јер мале грешке у софтверу могу бити скупе или опасне по живот. Из овог разлога је област верификације софтвера верома значаја. Последњих година су достигнути велики напреци у развоју алата за верификацију, али као и свугде, постоје проблеми који се тешко решавају. Анализа програмског кода се заснива на математичким моделима. У неким ситуацијама је коришћење стриктних математичких механизама тешко или чак немогуће за аутоматизацију. Са друге стране област машинског учења постиже високе резултате на пољу ???. Учење на основу искуства је кул. Технике машинског учења данас имају широку примену, а неке од њих су у оквиру статичке верификације софтвера. У раду ће бити дат преглед примена неких техника машинског учења у решавању одређених проблема верификације. 

% ---------------------------------------------------------------------------------------------------------------------
\section{Верификација софтвера}
% ---------------------------------------------------------------------------------------------------------------------

\emph{Верификација софтвера} је дисциплина развоја софтвера чији је циљ да
се бави проверавањем да ли програм задовољава све унапред задате захтеве.
Унапред задати захтев су спецификација свих жељених особина програма које се
постављају пре процеса верификације.
Највећа примена верификације софтвера је у оптимизацији кода и провере исправности.
\\
Што се тиче исправности морамо направити разлику између тоталне исправности и
делимичне исправности. Испитивање тоталне исправност захтева да се за све могуће
улазе покаже заустављање програма, то на жалост није могуће, \emph{"Halting problem"} је теорема
која је доказана да је неодлучива. Поред тога постоји још једна теорема \emph{"Rices theorem"} која
гласи "Ни једно не тривијално семантичко својство програма није одлучиво".
Према томе, због ових теорема у рачунарству је довољно показати да ће резултат евалуације
програма бити валидна вредност, тачније неће се десити да програм врати вредност која није валидна.
\\
Два приступа при верификацији софтвер су:  \emph{динамичка верификација} и \emph{статичка верификација} којом ћемо
се посебно бавити у наставку.

\paragraph{Динамичка верификација}
Динамичка верификација софтвера се врши у току извршавања програма и то најчешће скупом
унапред припремљених тестова који морају бити задовољени. Очигледно је да због неисцрпне
варијације могућих улаза овај вид тестирања нема за циљ валидацију програма, већ је
циљ динамичке верификације проналажење грешка на неком не тривијалном скупу тестова.

\paragraph{Статичка верификација}
Статичка верификација софтвера подразумева анализу софтвера без његовог извршавања,
тачније анализу кода применом неке од технника које ће бити описане у наставку.
Анализа кода може бити ручна или аутоматизована. Ручна метода подразумева да човек
проверава код, а аутоматизована подразумева описивање па чак и превођење кода
на неки од математичких језика, изабране математичке теорије.
Најчешћа употреба статичке верификације је оптимизација кода при превођењу.
=======
\emph{Верификација софтвера} је дисциплина развоја софтвера која за циљ има провераву да ли програм задовољава све унапред задате захтеве. Ти захтеви су представљени спецификацијом свих жељених особина програма и дефинишу се пре процеса верификације. Највећа примена верификације софтвера је у оптимизацији кода и провери исправности.


Потребно је направити разлику између тоталне и делимичне исправности. Испитивање тоталне исправности захтева да се за све могуће улазе покаже заустављање програма. Доказ заустављања у општем случају није могуће извести \cite{turing}. Такође, испитивање нетривијалних семантичких својстава је неодлучив проблем \cite{rice}. Према томе, у рачунарству је довољно испитати делимичну исправност софтвера, тј. довољно је показати да ће резултат извршавања програма бити валидна вредност.


Два приступа при верификацији софтверa су \emph{динамичка верификација} и \emph{статичка верификација} \cite{milena} 
\begin{itemize}
\item \textbf{Динамичка верификација}\\
Овај вид верификације се врши у току извршавања програма и то најчешће скупом 
унапред припремљених тестова који морају бити испуњени. Очигледно је да због неисцрпне варијације могућих улаза, овај вид тестирања нема за циљ валидацију програма, већ је циљ динамичке верификације проналажење грешка на неком не тривијалном скупу тестова.
\item \textbf{Статичка верификација}\\
Статичка верификација софтвера подразумева анализу софтвера без његовог извршавања, тачније анализу кода применом неке од технника које ће бити описане у наставку. Анализу кода може обављати човек, а може се и аутоматизовати. Аутоматизација подразумева описивање (па чак и превођење) кода језиком изабране математичке теорије.
\end{itemize}


У наставку ће бити више речи о статичкој верификацији. Биће описани механизми анализе кода, технике верификације и чести проблеми овог типа верификације.
% ---------------------------------------------------------------------------------------------------------------------
\subsection{Технике статичке верификације}
% ---------------------------------------------------------------------------------------------------------------------
\textbf{Апстрактна интерпретација} је је теорија семантичке апроксимације чија је идеја да направити
нову семантику над програмским језиком тако да се конкретан програм увек завршава.
Тако се анализа програма врши над апстрактном семантиком да би добили апроксимацију над
целом семантиком.
Коришћење апстрактне интерпретације се омогућава помоћу две функције: функције која пресликава
конкретне вредности у апстрактне вредности и функције која слика апстрактне вредности у конкретне
вредности. Неизбежно је заобићи губљење података при пресликавању из конкретних вредности у апстрактне
вредности јер је циљ показати да се над апострактном семантиком програм завршава.
Користећи овај математички оквир је релативно лако показати да ако се програм завршава у новој семантици
 програм ће бити коректан и у стварној семантици.
\\\\
\textbf{Симболичкa анализа} је метод статичке анализе који анализира програмске
вредности који могу да се мењају. Овај метод има за циљ да изведе
математички модел који прецизно описује израчунавање, заправо може се посматрати као нека врста
компајлера који преводи програм у симболичке изразе.
Квалитет алгебарских система као што су (Axiom, Derive, Macsyma, Maple, Mathematica,
MuPAD, and Reduce) је веома битан јер квалитет овог начина анализе у великој меримо
зависи од паметних алгебарских упрошћавања.
\\\\
\textbf{ Проверавање ограничених модела (енг. Bounded model checking)}
Проверавање ограничених модела је техника верификације која се највише користи у индустрији
полуповодника, тачније верификација логичкх кола. Укратко речено смисао је да се логичка кола
опишу исказном логиком. Следећи корак је провера задовољивости добијене исказне формуле.
Испитивање задовољивости формула је НМ-тежак проблем, и за решавање овог питања
користе се сат решавачи. Ефикасност сат решавача је од кључног значаја за ову технику.
Ова техника је такође примењљива и за анализу софтвера, један од начина примене
је посматрање извршавања целокупног програма као скупа стања, односно као један
коначни аутомат у ком се прелази из стања у стање. Ако се тако посматра програм могуће
је описати сва стања искасном логиком затим повезати сва стања и тако добијену формулу
пустити у сат решавач. Резултат сат решавача је може бити формула је задовољива сто би значило
да је програм коректан или ако је формула незадовољива резултат ће бити контрапример
којим се показује да програм није коректан и може представљати основу за дебаговање.
\\\\
\noindent Литература:
A Survey of Static Program Analysis Techniques \cite{survey}\\
A Survey of Automated Techniques for Formal Software Verification \cite{dkw2008}\\
=======
Претходним поглављем су дефинисани основни појмови верификације софтвера. Предочено је да је немогуће у општем случају испитати заустављање програма и анализирати нетривијална семантичка својства. Ово поглавље ће дати увид у аутоматизоване технике статичке анализе.

\subsection{Апстрактна интерпретација}
Апстрактна интерпретација је теорија семантичке апроксимације чија је идеја да изгради нову семантику над програмским језиком тако да се конкретан програм увек завршава. Тако се анализа програма врши над апстрактном семантиком да би се добила апроксимација над целом семантиком. Коришћење апстрактне интерпретације се омогућава помоћу две функције: функције која пресликава конкретне вредности у апстрактне вредности и функције која слика апстрактне вредности у конкретне вредности. Неизбежно је заобићи губљење података при пресликавању из конкретних вредности у апстрактне вредности јер је циљ показати да се над апострактном семантиком програм завршава. Користећи овај математички оквир је релативно лако показати да ако се програм завршава у новој семантици програм ће бити коректан и у стварној семантици.


\subsection{Симболичкa анализа}
Симболичкa анализа је метод статичке анализе који анализира програмске вредности који могу да се мењају. Овај метод има за циљ да изведе математички модел који прецизно описује израчунавање, заправо може се посматрати као нека врста компајлера који преводи програм у симболичке изразе. Квалитет алгебарских система као што су (Axiom, Derive, Macsyma, Maple, Mathematica, MuPAD, and Reduce) је веома битан јер квалитет овог начина анализе у великој мерим зависи од паметних алгебарских упрошћавања.


\subsection{Проверавање ограничених модела}
\textit{Проверавање ограничених модела} (енг. Bounded model checking) је техника верификације која се највише користи у индустрији полуповодника, тачније верификација логичкх кола. Укратко речено смисао је да се логичка кола опишу исказном логиком. Следећи корак је провера задовољивости добијене исказне формуле. Испитивање задовољивости формула је НМ-тежак проблем, и за решавање овог питања користе се сат решавачи. Ефикасност сат решавача је од кључног значаја за ову технику. Ова техника је такође примењљива и за анализу софтвера, један од начина примене је посматрање извршавања целокупног програма као скупа стања, односно као један коначни аутомат у ком се прелази из стања у стање. Ако се тако посматра програм могуће је описати сва стања искасном логиком затим повезати сва стања и тако добијену формулу пустити у сат решавач. Резултат сат решавача је може бити формула је задовољива сто би значило да је програм коректан или ако је формула незадовољива резултат ће бити контрапример којим се показује да програм није коректан и може представљати основу за дебаговање.\cite{survey}\cite{dkw2008}.

Овим поглављем смо направили кратак преглед најважнијих техника аутоматизоване статичке анализе. Показује се да наведене
технике дају неку врсту формалне гаранције квалитета софтвера. Апстрактна семантика је уопштени начин рада кад се прави
програм за анализу софтверa, тако да се сви остали програми који спроводе анализу могу бити посматрани као инстанце апстрактне
семантике.  Симболичкa анализа је техника којом се изводи прецизна карактеризација програмских својстава на параметарски начин, а
техника проверавања ограничених модела је моћна за октривање једноставних грешака али на жалост нису у стању да
докажу чак ни дубоке петље. \\
У следећем поглављу ћемо објаснити основне аспекте области машинског учења.

% ---------------------------------------------------------------------------------------------------------------------
\section{Машинско учење}
% ---------------------------------------------------------------------------------------------------------------------
У претходним поглављима је описана статичка верификацију софтвера. Показана је важност те области и изложене су технике верификације. Ово поглавље ће приближити област машинског учења и описаће главне аспекте ове дисциплине,

\subsection{Основе машинског учења}
\begin{definic}
%A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E.
``За програм кажемо да учи из искуства E кроз обављање задатка T са мером квалитета P, ako повећањем искуства E расте мера P за обављен задатак T.''
\\[5pt]
\rightline{{\rm --- Tom M. Mitchell} \cite{tom-ml}}
\end{definic}


Машинско учење се може посматрати као област рачунарства која се бави анализом алгоритама који генерализују. Са практичног аспекта, генерализација може значити уопштавање закона над датим подацима.


Три најзначајније подобласти машинског учења су: \textit{надгледано учење}, \textit{ненадгледано учење} и \textit{учење условљавањем}. Подаци из којих алгоритми машинског учења уче, могу бити обележени, необележени и могу се генерисати у фази учења. Оваква природа података је основ за разликовање три наведене подобласти.\cite{tom-ml}.


Међу многим проблемима над којима су често примењивани алгоритми машинског учења, истактнути су проблем регресије и проблем класификације. Под проблемом класификације се подразумева испитивање датог објекта и одређивање класе којој он припада на основу његових својстава (атрибута). Типичан пример класификације је одређивање порекла тумора на основу његове величине. Проблем регресије представља предвиђање понашања непрекидне променљиве. Пример регресије је предикцију цене стамбеног објекта на основу његове величине, броја соба и разних других релевантних карактеристика.


Пре примене машинског учења потребно је проучити проблем који се решава, уочити његове специфичности и припремити и анализирати податке из којих ће алгоритми учити. Након детаљне анализе, врши се одабир одговарајућег математичког модела. Изабрали модел се даље тренира над подацима. Тренинг се понавља довољан број пута при чему у свакој итерацији модел евалуира тј. мери се грешка коју тај модел прави. Након сваког мерења, у зависности од алгоритма, врши се корекција модела у циљу минимизације грешке.


У даљем тексту ће бити приказани конкретни алгоритми који су релевантни за процес верификације и дискутоваће се о њиховим својствима. 


\subsection{Значајност машинског учења}
Конвенционалан начин решавања проблема у рачунарству се своди на формално дефинисање низа корака који улазне параметре трансформишу не би ли дошли до резултата. Овакав приступ је користан у ситуацијама када је потребно решити проблеме који су човеку изазовни, као што су компликоване рачунске операције, сортирање великих низова и томе слично. Поставља се питање: како написати програм који би обављао задатке које човек свакодневно лако обавља? На пример, да ли је могуће написати програм који би био у стању да препознаје објекте са фотографија?


\textit{Рачунарски вид} (енг. computer vision) је дисциплина која се бави овим проблемом.\cite{old-cv}. Алгоритми који су примењивани пре раста популарности машинског учења нису показали значајне резултате. Могли су да генеришу једноставне геометријске моделе који нису давали задовољавајуће резултате. Дубоке неуронске мреже су алгоритами машинског учења који су показали значајне напретке у овој области \cite{new-cv}.


Класификација дела програма на валидна стања и она која могу резултовати грешком је од кључног значаја за ефикасност алата за верификацију \cite{Brun04findinglatent} \cite{KrishnaPW15}. Конкретним проблемима и њиховим решењима ћемо се бавити у наредним поглављима.


\subsection{Технике машинског учења}
О општој слици примене алгоритама машинског учења је било више речи у уводном делу овог поглавља. Како је проблем класификације централни проблем над којиме се примењује машинско учење у статичкој верификацији, биће представљена два алгоритма која решавају тај проблем. Зарад потпуности, биће описан и један алгоритам решавања регресионих проблема.


\subsubsection*{Линеарна регресија}
Као што је речено у уводном делу, регресиони проблем представља предвиђање циљне променљиве непознате инстанце на основу осталих њених атрибута. Нека је $y_i$ циљна променљива, а $\vec{x} = (x_1, x_2, ..., x_n)$ вектор атрибута. У примеру предикције вредности куће то могу бити број соба, квадратура куће итд. Инстанца из скупа података ће онда бити $(\vec{x}_i, y_i)$. Модел линеарне регресије, параметризован вектором $w$, који описује законитост је следећи:
\begin{equation}
    h(\vec{x}_i) = w^T \cdot \vec{x}_i
\end{equation}


Грешка коју модел прави је потребно представити погодним избором функције грешке $L(w)$. Чест избор ове функције је средњеквадратна грешка коју модел прави над свим инстанцама из тренинг скупа.
\begin{equation}
L(w) = \frac{1}{N}\sum \limits_{i=1}^{N} (h(\vec{x}_i) - y_i)^2
\end{equation}

Тренинг се врши тако што се одређеном оптимизационом техником минимизује функција грешке по параметрима $w$.


\subsubsection*{Стабла одлучивања}
Стабла одлучивања представљају један од основних метода класификације. Употребу стабала одлучивања оправдава њихова висока интерпретабилност \cite{dct-survey}. У листовима стабла одлучивања се налазе вредности циљне променљиве, односно у случају класификације, класе којима инстанца може припасти. Унутрашњи чворови стабла представљају атрибуте по којима се врши подела. Када су ти атрибути категоричког типа, потомци датог чвора су добијени из свих могућих вредности које тај категорички атрибут може имати. У случају да је атрибут некатегоричког типа, најчешће се врши подела могућих вредности на дисјунктне интервале тако да свако дете тог чвора одговара једном од интервала. Слика \ref{fig:stablo} приказује једно могуће стабло одлучивања добијено на основу података.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{decision_tree.png}
\end{center}
\caption{Стабло одлучивања}
\label{fig:stablo}
\end{figure}


\subsubsection*{Метода потпорних вектора}
Проблем класификације се може разматрати у селедећем контексту. Инстанце које се класификују су представљене тачкама у неком високодимензионалном простору. Бинарни класификатор је хиперраван која дели простор на два дела, тако да се у једном делу простора нађу све инстанце које припадају једној класи, а у другом делу ће се наћи оне које припадају другој класи. Раздвајајућих хиперравни може бити више, па је зато потребно одабрати хиперраван која боље описује поделу међу подацима \cite{svm-intro}.


Маргина класификације је најмање растојање између тачака које се налазе у различитим потпросторима и бинарног класификатора. Слика \ref{fig:svm} приказује хиперравни $B_1$ и $B_2$. Прва хиперраван боље раздваја податке. Маргина $(b_11, b_12)$ je значајно већа од маргине $(b_{21}, b_{22})$ и то је оно што први класификатор чини знатно бољим.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.6]{svn.png}
\end{center}
\caption{Приказ различитих хиперравни}
\label{fig:svm}
\end{figure}

Максимизацијом маргине се добија класификатор који боље описује поделу. Зарад конвенције, проблем максимизације се своди на проблем минимизације, те се добија следећи оптимизациони проблем:
\begin{equation}
    \min_{w, w_0} \frac{ {\norm{w}}^2 }{2}
\end{equation}


Линеарна регресија, стабла одлучивања и метод потпорних верктора су приказани у овом поглављу због својих примена у проблемима статичке верификације. Поглавље шест се бави овим применама. Следеће поглавље ће представити релевантне проблеме верификације и даће основ за примену ових метода.

% ---------------------------------------------------------------------------------------------------------------------
\section{Одабрани проблеми статичке верификације}
% ---------------------------------------------------------------------------------------------------------------------
%\textit{Уређени бинарни дијаграми одлучивања} (енг. ordered binary decision diagrams, OBDD) \cite{obdd} представљају алат за ефикасну анализу Булових функција.\cite{eval-obdd}\cite{logic-ver-synth}. Логичке импликације бивају откривене конструисањем УБДО за разне улазе. Симболичком обрадом УБДО дијаграма и применом закона контрапозиције се могу научити додатне импликације. \cite{Jain}. Статичка верификација се даље спроводи успостављањем еквиваленције између два УБДО, тј. проналаском одговарајућег скупа импликација. Еквивалентност два УБДО се изводи проналажењем сличности унутрашње структуре између два дијаграма.
До сада смо видели стандардне проблеме и технике статичке верификације и машинског учења. У овом поглављу ћемо издвојити значајне проблеме верификације на које су, применама алгоритама машинског учења постигнути значајнији резултати.


Статичка верификација мора бити у стању да разликује позитивна стања програма од негативних.
Негативна су она која доводе програм до грешке. \textit{Интерполантама} (енг. interpolants)
називамо предикате који раздвајају позитивна од негативних стања.
У статичкој верификацији се коришћењем оваквих интерполанти гради даљи доказ.
Показано је да се ове интерполанте могу интерпретирати као бинарни класификатори.
Проблем који се овде јавља је генерисање интерполанти, тј проналажење одговарајућег класификатора \cite{Sharma_interpolantsas}.
У делу  \ref{ssec:interpolant} детаљније је описан приступ коришћен у \cite{Sharma_interpolantsas}.

Поред итерполанти, могуће је препознати нетривијална својства програма која даље резултују грешком.
Грађењем \textit{класификатора нетачне инваријанте} (енг. False Invariant Classifier) је могуће рангирати
својства програма по томе колику вероватноћу за грешком та својства проузрокују.
Одређивање нетривијалног својства датог програма је у општем случају неодлучив проблем \cite{turing, Brun04findinglatent}.

Код апстрактне интерпретације је остварив баланс између прецизности изгенерисане инваријанте и скалабилности система за верификацију. Овај баланс је последица детаљне анализе апстрактног синтаксног стабла. Одабир инваријанте је тежак проблем и показано је да се може утврдити тестирањем \cite{Sharma_interpolantsas, KrishnaPW15}.

Проблеми које смо представили овим поглављем су решена користећи одговарајуће технике машинског учења. У наредом поглављу ћемо се бавити тим решењима, даћемо увид у начине на који су та решења примењена и покушати да одговоримо на питање како наставити усавршавање тих техника.

% ---------------------------------------------------------------------------------------------------------------------
\section{Неке примене техника машинског учења у статичкој верификацији}
\label{sec:primene}
% ---------------------------------------------------------------------------------------------------------------------
\color{blue}
Ово је есенција. Одабирају се проблеми из претходног поглавља и показује се
како се решава. Прво иде неки уводни део, онда из литературе се покупе те технике
и таксативно се наводе (принцип проблем-решење).
\color{black}
\subsection{Проналажење интерполанти}
\label{ssec:interpolant}

Неформално говорећи, интерполанта представља предикат који раздваја позитивна стања програма
од негативних. Примена машинског учења у проналажењу интерполанти огледа се у добијању модела
који представља саму интерполанту. У делу \ref{sssec:interpolant_svm} изложене су основе из \cite{Sharma_interpolantsas} базиране на методу
потпорних вектора, док је у делу \ref{sssec:interpolant_dt} изложен приступ из рада \cite{KrishnaPW15} базиран на стаблима одлучивања. Експериментални резултати
показали су да приступи базирани на машинском учењу јесу упоредиви са традиционалним техникама.

%Користи се теорија линеарне аритметика о којој се више може пронаћи у \cite{Kroening2008}.

\paragraph{Проналажење интерполанти користећи метод потпорних вектора\\ \\}
\label{sssec:interpolant_svm}
 Нека су $A$ и $B$ формуле у теорији линеарне аритметике \cite{Kroening2008}.
\begin{equation}
\phi ::= w^Tx + d \geq 0 \ | \ true \ | \ false \ | \ \phi \land \phi \ | \ \phi \lor \phi \ | \ \neg \phi
\end{equation}
При чему је $\vec{w} = (w_1, ..., w_n)^T \in R^n$ вектор константи у простору $R^n$; $\vec{x} = (x_1, ..., x_n)^T$
вектор променљивих из простора $R^n$.

\begin{definic}
Интерполанта за пар формула (А, B) тако да $A \land B \equiv \bot$ је формула I која задовољава $A \Rightarrow I, I \land B \equiv \bot$
при чему формула I садржи само променљиве које се јављају у формулама A и B.
\end{definic}

На слици \ref{fig:interpolant_example} приказан је програмски код који ће бити корићен као илустрација.
Функција непознат број пута инкрементира променљиве $x$ и $y$, потом их декрементира све док променљива $x$
не постане 0. Коначно, уколико је $y \neq 0$ онда програм одлази у стање грешке.
Приметимо да је инваријанта $x = y$ довољна да се докаже да програм никад неће доћи у стање грешке.

\begin{figure}[h!]
\begin{center}
    \includegraphics[scale=0.17]{./slike/interpolant_code.png}
\end{center}
\caption{Пример кода}
\label{fig:interpolant_example}
\end{figure}

Претпоставимо да је функцијa \texttt{foo()} извршила на следећи начин (у заградама су хронолошки наведени линије инструкција): $(1, 2, 3, 2, 4, 5, 4, 6, 7)$ који
води у стање грешке.  Поделимо ток на два скупа, A и B и пронађимо интерполанте за наведени ток.

Скуп A садржи вредности $x$ и $y$ које се добијају након извршавања линија 1, 2 и 3. У скупу B се налазе оне вредности $x$ и $y$
које би се добиле уколико би програм извршио линије 4, 5, 6 и 7 чиме би програм дошао у завршно стање.

Имамо да $A \land B \equiv \bot$ при чему важи:

\begin{equation*}
\begin{split}
    A & \equiv x_1 = 0 \land y_1 = 0 \land if\_then\_else(b,\  x = x_1 \land y = y_1,\ x = x_1 + 1 \land y = y_1 + 1)     \\
    B & \equiv if\_then\_else(x = 0,\ x_2 = x \land y_2 = y,\ x_2 = x - 1 \land y_2 = y-1) \land x_2 = 0 \land \neg (y_2 = 0)
\end{split}
\end{equation*}

$A$ представља скуп достижних стања док $B$ представља скуп стања која воде у стање грешке. Интерполанта је доказ да су
скупови $A$ и $B$ дисјунктни и изражава се користећи заједничке променљиве из скупова $A$ и $B$. Затим, помоћу доказивача теорема се рачунају вредности за $(x, y)$ које задовољавају формуле $A$ и $B$ \cite{Sharma_interpolantsas}.

Добијене вредности представљају скуп инстанци над којим се може тренирати класификациони модел (попут логистичке регресије или потпорних вектора).
Позитивне инстанце представљају вредности променљивих које задовољавају формулу $A$ и аналогно, негативне инстанце представљају вредности
променљивих које задовољавају формулу $B$.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{./slike/interpolant.png}
\end{center}
\caption{Класификација у тражењу интерполанти}
\label{fig:interpolant_svm}
\end{figure}

Слика \ref{fig:interpolant_svm} приказује вредности променљивих $(x, y)$ за $A$ као плусеве (тачке $(0, 0)$ и $(1, 1)$)
и $B$ као кружиће (тачке $(1, 0)$ и $(0, 1)$). Приказани модел је добијен коришћењем метода потпорних вектора. Резултујуће праве одговарају једначинама:
\begin{equation*}
\begin{split}
    e_1: 2y &= 2x + 1 \\
    e_2: 2y &= 2x - 1
\end{split}
\end{equation*}
Интерполанта која се одавде може извести је
\begin{equation*}
2y \leq 2x + 1 \, \land 2y \geq 2x - 1
\end{equation*}

Овај предикат представља инваријанту чијим доказивањем се показује да програм не може доћи у стање грешке.
Једноставнија интерполанта $x = y$ се може добити транислирањем добијених правих што ближе позитивним истанцама,
докле год се одржава сепарабилност позитивних и негативних инстанци.

Табела \ref{table:interpolant_table} приказује резултате из \cite{Sharma_interpolantsas} на неким од познатих
примера. Интерполанте које су означене са \textit{исто} су интерполанте које су добијене користећи решавач \textsc{OpenSMT}.

\begin{table}[]
\centering
\caption{Добијене интерполанте на неким од познатијих тест примера у области.}
\label{table:interpolant_table}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Датотека} & \textbf{Време (с)} 	& \textbf{Интерполанта}                                                     			\\ \hline
\texttt{f1a} 	& 0.022              	& \texttt{((y = 1 | x \textless= 0) \& x = 1) | (y = 0 \& (y = 1 | x \textless= 0))} 	\\ \hline
\texttt{ex1}    & 0.021              	& \texttt{xa + 2*ya >= 0 | xa + 2*ya >= 5 | xa + 2*ya >= 5}                             \\ \hline
\texttt{f2}     & 0.20               	& \texttt{y <= 3*x | y <= 3*x + 1 | y <= 3*x + 1} 										\\ \hline
\texttt{nec1}   & није доступно      	& Није пронађена                                                            			\\ \hline
\texttt{nec2}   & 0.018 				& \texttt{x < y} (исто) 																\\ \hline
\texttt{nec3}   & 0.016      			& \texttt{y <= 9} (исто)																\\ \hline
\texttt{nec4}   & 0.021      			& \texttt{(x = y | y = 0) | (y = x) | (y = x)} 											\\ \hline
\texttt{nec5}   & 0.018      			& \texttt{s >= 0} (исто) 																\\ \hline
\texttt{pldi08} & 0.017      			& \texttt{y > x}																		\\ \hline
\texttt{fse06}  & 0.017      			& \texttt{y + x >= 0 \& y >= 0 \& y >= 0 \& y >= 0}										\\ \hline
\end{tabular}
\end{table}

\subsubsection{Проналажење интерполанти користећи стабла одлучивања}
\label{sssec:interpolant_dt}

Интерполанте се могу извести и другим методима машинског учења. Рад \cite{KrishnaPW15} илуструје приступ који
користи стабла одлучивања. За програмски код се генеришу позитивне и негативне инстанце над којима се гради
стабло одлучивања користећи похлепни алгоритам. Правила добијена у стаблу се трансформишу у формулу која
се потом проверава да ли је инваријанта користећи \textsc{SMT} решавач.

Резултати су показали да једноставни похлепни алгоритам који гради стабло даје и једноставне формуле
за интерполанте. Стабло је лако научило комплексне бинарне инваријанте као једноставне коњункције.

Слика \ref{fig:interpolant_example2} приказује пример програма и његова стања која се могу добити на основу
покретања самог програма. Добра стања можемо добити пратећи претпоставке (линија 2), бележећи ток променљивих
и провером да ли је испуњен услов $x \neq 0$ са линије 12. Лоша стања можемо добити игноришући услов са линије 2.
На пример, тачка $(-2, -2)$ тачка $(-4, -4)$ представљају лоша стања.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{./slike/interpolant2.png}
\end{center}
    \caption{Пример програма. Лева страна приказује код, десна страна садржи добра стања (плаве тачке) и лоша
    стања (црвене тачке).}
\label{fig:interpolant_example2}
\end{figure}

Слика \ref{fig:interpolant_dt} приказује стабло добијено применом алгоритма описаног у \cite{KrishnaPW15}.
Добијени алгоритам је сложености $O(mn \log(n))$, где је $m$ број атрибута а $n$ број инстанци.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{./slike/stablo_odlucivanja.png}
\end{center}
    \caption{Стабло одлучивања добијено за пример са слике \ref{fig:interpolant_example2}.}
\label{fig:interpolant_dt}
\end{figure}

\paragraph{Грађење класификатора нетачне инваријанте\\ \\}

Грађење класификатора нетачне инваријанте \cite{Brun04findinglatent} представља приступ којим се користећи класификатор рангирају
својства програма по њиховој вероватноћи да проузрокују грешку. Програмеру се приказује листа пронађених
програмских својстава која треба да скрати простор претрагe у потрази за грешком. У раду су коришћене две техника класификације
машинског учења, метода потпорних вектора и метода стабла одлучивања. Као помоћ при проналажењу својстава програма, користи
се \textsc{Daikon} динамички детектор инваријанти \cite{Daikon}.

\textsc{Daikon} детектује својства специфичних делова програма попут улаза и излаза из процедура.
За скаларне променљиве $x$, $y$ и $z$, и константе $a$, $b$ и $c$, неки примери својстава су:
\begin{itemize}
    \item једнакост са константом ($x = a$);
    \item провера опсега ($a \leq x \leq b$);
    \item линеарне везе ($z = ax + by + c$);
    \item уређење ($x \leq y$);
    \item функције ($y = fn(x)$).
\end{itemize}

За секвенцијалне променљиве (низови, листе) нека својства су:
\begin{itemize}
    \item минимум и максимум;
    \item лексикографско уређење;
    \item својства која важе за све елементе;
    \item припадност ($x \in y$).
\end{itemize}

\textsc{Daikon} може пронаћи и импликације попут \textit{Ако је $p \neq null$ онда $p.value > x$}
и дисјункције попут \textit{p.value > c $\lor \ p.left \in T$}.

Добијена својства је потребно превести у векторе како би се омогућила примена алгоритама машинског учења.
Један пример кодирања добијених својстава је приказан на слици \ref{fig:latent_coding}.
У раду је кодирање изведено у векторе димензије 388 јер се показало да су коришћени алгоритми
успевали да игноришу ирелевантне атрибуте те висока димензионалност није сметала.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.18]{./slike/latent_errors_table.png}
\end{center}
    \caption{Пример кодирања програмских својстава у вектор.}
\label{fig:latent_coding}
\end{figure}

Na slici \ref{fig:latent_code} је приказан програмски код, а на слици \ref{fig:latent_example}
листа програмских својстава који могу бити потенцијални проблеми. Добијена листа програмских својстава
представља класификоване инстанце које потенцијално откривају грешку.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.16]{./slike/latent_code.png}
\end{center}
    \caption{Пример програмског кода.}
\label{fig:latent_code}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.16]{./slike/latent_examples.png}
\end{center}
    \caption{Листа понуђених програмских својстава}
\label{fig:latent_example}
\end{figure}

% ---------------------------------------------------------------------------------------------------------------------
\section{Закључак}
% ---------------------------------------------------------------------------------------------------------------------
Радови приказани у делу \ref{sec:primene} показали су да област машинског учења може пронаћи примену у области статичке
верификације софтвера. Добијени резултати су били барем упоредиви са другим приступима, а у неким случајевима и доста
бољи. Неки од проблема који се јављају при употребни алгоритама машинског учења јесу неинтерпретабилност добијеног модела и
неегзактна предвиђања које модел врши. Проблем интерпретабилности је превазиђен стаблима одлучивања \cite{KrishnaPW15, Sharma_interpolantsas}
која су позната да дају интерпретабилне моделе, док је проблем неегзактног предвиђања ублажен у раду \cite{Brun04findinglatent}
где се као резултат даје листа програмских својстава које човек анализира. Уколико је неко својство погрешно класификовано,
неће проузроковати велику грешку.

\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski}
\bibliographystyle{plain}


\end{document}
